<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Reader &#8212; asws 1.0.0a documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.0a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Reasons" href="reason.html" />
    <link rel="prev" title="Fragment Context" href="fragment.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-websocket.stream.reader">
<span id="reader"></span><h1>Reader<a class="headerlink" href="#module-websocket.stream.reader" title="Permalink to this headline">¶</a></h1>
<p>You should not make an instance of the WebSocketReader class yourself, rather you should only make use of it through a 
callback registerd with <a class="reference internal" href="client.html#websocket.client.Client.message" title="websocket.client.Client.message"><code class="xref py py-meth docutils literal"><span class="pre">message()</span></code></a></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@client</span><span class="o">.</span><span class="n">message</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">def</span> <span class="nf">on_message</span><span class="p">(</span><span class="n">reader</span><span class="p">:</span> <span class="n">WebSocketReader</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Read from the reader here...</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
</pre></div>
</div>
<dl class="class">
<dt id="websocket.stream.reader.WebSocketReader">
<em class="property">class </em><code class="descclassname">websocket.stream.reader.</code><code class="descname">WebSocketReader</code><span class="sig-paren">(</span><em>kind</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/websocket/stream/reader.html#WebSocketReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#websocket.stream.reader.WebSocketReader" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>data_type</strong> &#8211; The type of data frame the client sent us, this is the default kind for <a class="reference internal" href="#websocket.stream.reader.WebSocketReader.get" title="websocket.stream.reader.WebSocketReader.get"><code class="xref py py-meth docutils literal"><span class="pre">get()</span></code></a>.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="websocket.stream.reader.WebSocketReader.at_eof">
<code class="descname">at_eof</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#websocket.stream.reader.WebSocketReader.at_eof" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the buffer is empty and &#8216;feed_eof&#8217; was called.</p>
</dd></dl>

<dl class="method">
<dt id="websocket.stream.reader.WebSocketReader.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>kind=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/websocket/stream/reader.html#WebSocketReader.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#websocket.stream.reader.WebSocketReader.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads all of the bytes from the stream.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kind</strong> (<a class="reference internal" href="enums.html#websocket.enums.DataType" title="websocket.enums.DataType"><code class="xref py py-class docutils literal"><span class="pre">DataType</span></code></a>) &#8211; Specifies the type of data returned, default is <code class="xref py py-attr docutils literal"><span class="pre">data_type</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><a class="reference external" href="https://docs.python.org/3.6/library/functions.html#bytes" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">bytes</span></code></a> if kind is DataType.BINARY, <a class="reference external" href="https://docs.python.org/3.6/library/stdtypes.html#str" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">str</span></code></a> if kind is DataType.TEXT</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="websocket.stream.reader.WebSocketReader.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>n=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#websocket.stream.reader.WebSocketReader.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read up to <cite>n</cite> bytes from the stream.</p>
<p>If n is not provided, or set to -1, read until EOF and return all read
bytes. If the EOF was received and the internal buffer is empty, return
an empty bytes object.</p>
<p>If n is zero, return empty bytes object immediately.</p>
<p>If n is positive, this function try to read <cite>n</cite> bytes, and may return
less or equal bytes than requested, but at least one byte. If EOF was
received before any byte is read, this function returns empty byte
object.</p>
<p>Returned value is not limited with limit, configured at stream
creation.</p>
<p>If stream was paused, this function will automatically resume it if
needed.</p>
</dd></dl>

<dl class="method">
<dt id="websocket.stream.reader.WebSocketReader.readexactly">
<code class="descname">readexactly</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#websocket.stream.reader.WebSocketReader.readexactly" title="Permalink to this definition">¶</a></dt>
<dd><p>Read exactly <cite>n</cite> bytes.</p>
<p>Raise an IncompleteReadError if EOF is reached before <cite>n</cite> bytes can be
read. The IncompleteReadError.partial attribute of the exception will
contain the partial read bytes.</p>
<p>if n is zero, return empty bytes object.</p>
<p>Returned value is not limited with limit, configured at stream
creation.</p>
<p>If stream was paused, this function will automatically resume it if
needed.</p>
</dd></dl>

<dl class="method">
<dt id="websocket.stream.reader.WebSocketReader.readline">
<code class="descname">readline</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#websocket.stream.reader.WebSocketReader.readline" title="Permalink to this definition">¶</a></dt>
<dd><p>Read chunk of data from the stream until newline (b&#8217;
&#8216;) is found.</p>
<blockquote>
<div><p>On success, return chunk that ends with newline. If only partial
line can be read due to EOF, return incomplete line without
terminating newline. When EOF was reached while no bytes read, empty
bytes object is returned.</p>
<p>If limit is reached, ValueError will be raised. In that case, if
newline was found, complete line including newline will be removed
from internal buffer. Else, internal buffer will be cleared. Limit is
compared against part of the line without newline.</p>
<p>If stream was paused, this function will automatically resume it if
needed.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="websocket.stream.reader.WebSocketReader.readuntil">
<code class="descname">readuntil</code><span class="sig-paren">(</span><em>separator=b'\n'</em><span class="sig-paren">)</span><a class="headerlink" href="#websocket.stream.reader.WebSocketReader.readuntil" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from the stream until <code class="docutils literal"><span class="pre">separator</span></code> is found.</p>
<p>On success, the data and separator will be removed from the
internal buffer (consumed). Returned data will include the
separator at the end.</p>
<p>Configured stream limit is used to check result. Limit sets the
maximal length of data that can be returned, not counting the
separator.</p>
<p>If an EOF occurs and the complete separator is still not found,
an IncompleteReadError exception will be raised, and the internal
buffer will be reset.  The IncompleteReadError.partial attribute
may contain the separator partially.</p>
<p>If the data cannot be read because of over limit, a
LimitOverrunError exception  will be raised, and the data
will be left in the internal buffer, so it can be read again.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="fragment.html" title="previous chapter">Fragment Context</a></li>
      <li>Next: <a href="reason.html" title="next chapter">Reasons</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/modules/reader.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Erlend Tobiassen.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/modules/reader.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>